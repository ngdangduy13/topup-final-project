/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.4.0 (NJsonSchema v9.12.7.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import * as moment from 'moment';

export class ServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:3000/api";
    }

    /**
     * Register new account
     * @param body (optional) 
     * @return successful operation
     */
    register(body: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Login
     * @param body (optional) 
     * @return successful operation
     */
    login(body: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Forgot password
     * @param body (optional) 
     * @return successful operation
     */
    forgotPassword(body: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/auth/forgotpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Reset password
     * @param token token
     * @param body (optional) 
     * @return Success! Your password has been changed.
     */
    resetPassword(token: string, body: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/auth/resetpassword/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Find users
     * @param token token
     * @param searchTerm (optional) search by username or email
     * @param role (optional) search by role
     * @param pageIndex (optional) the current page index
     * @param pageSize (optional) items in each page
     * @param sortBy (optional) field name to sort
     * @param pageOrientation (optional) next page or previous page
     * @return successful operation
     */
    findUsers(token: string, searchTerm: string | undefined, role: string | undefined, pageIndex: string | undefined, pageSize: number | undefined, sortBy: string | undefined, pageOrientation: boolean | undefined): Promise<string> {
        let url_ = this.baseUrl + "/users?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "role=" + encodeURIComponent("" + role) + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageOrientation === null)
            throw new Error("The parameter 'pageOrientation' cannot be null.");
        else if (pageOrientation !== undefined)
            url_ += "pageOrientation=" + encodeURIComponent("" + pageOrientation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUsers(_response);
        });
    }

    protected processFindUsers(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? UsersDTO.fromJS(resultData500) : new UsersDTO();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Get user by id
     * @param token token
     * @param userId userId
     * @return successful operation
     */
    findUserById(token: string, userId: string): Promise<string> {
        let url_ = this.baseUrl + "/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUserById(_response);
        });
    }

    protected processFindUserById(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? UsersDTO.fromJS(resultData500) : new UsersDTO();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Update user
     * @param token token
     * @param userId userId
     * @param body (optional) 
     * @return successful operation
     */
    updateUser(token: string, userId: string, body: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Update roles
     * @param userId userId
     * @param body (optional) 
     * @return successful operation
     */
    updateRoles(userId: string, body: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/users/{userId}/updateroles";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRoles(_response);
        });
    }

    protected processUpdateRoles(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Redeem reward points
     * @param userId userId
     * @param searchTerm (optional) search by name
     * @param pageIndex (optional) the current page index
     * @param pageSize (optional) items in each page
     * @param sortBy (optional) field name to sort
     * @param pageOrientation (optional) next page or previous page
     * @return successful operation
     */
    getRedeemPoints(userId: string, searchTerm: string | undefined, pageIndex: string | undefined, pageSize: number | undefined, sortBy: string | undefined, pageOrientation: boolean | undefined): Promise<string> {
        let url_ = this.baseUrl + "/users/{userId}/redeempoints?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageOrientation === null)
            throw new Error("The parameter 'pageOrientation' cannot be null.");
        else if (pageOrientation !== undefined)
            url_ += "pageOrientation=" + encodeURIComponent("" + pageOrientation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRedeemPoints(_response);
        });
    }

    protected processGetRedeemPoints(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Redeem reward points
     * @param userId userId
     * @param body (optional) 
     * @return successful operation
     */
    redeemPoints(userId: string, body: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/users/{userId}/redeempoints";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRedeemPoints(_response);
        });
    }

    protected processRedeemPoints(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Cancel redeeming reward points
     * @param userId userId
     * @param body (optional) 
     * @return successful operation
     */
    cancelredeemPoints(userId: string, body: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/users/{userId}/cancelredeempoints";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelredeemPoints(_response);
        });
    }

    protected processCancelredeemPoints(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Find quizzes
     * @param token token
     * @param searchTerm (optional) search by name
     * @param state (optional) search by quiz state
     * @param pageIndex the current page index
     * @param pageSize items in each page
     * @param sortBy (optional) field name to sort
     * @param pageOrientation (optional) next page or previous page
     * @param isActive beacon is active
     * @param uuid (optional) uuid
     * @param major (optional) major
     * @param minor (optional) minor
     * @return successful operation
     */
    getAllQuizzes(token: string, searchTerm: string | undefined, state: string | undefined, pageIndex: string, pageSize: number, sortBy: string | undefined, pageOrientation: boolean | undefined, isActive: boolean, uuid: string | undefined, major: number | undefined, minor: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/quizzes?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (pageIndex === undefined || pageIndex === null)
            throw new Error("The parameter 'pageIndex' must be defined and cannot be null.");
        else
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageOrientation === null)
            throw new Error("The parameter 'pageOrientation' cannot be null.");
        else if (pageOrientation !== undefined)
            url_ += "pageOrientation=" + encodeURIComponent("" + pageOrientation) + "&"; 
        if (isActive === undefined || isActive === null)
            throw new Error("The parameter 'isActive' must be defined and cannot be null.");
        else
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (uuid === null)
            throw new Error("The parameter 'uuid' cannot be null.");
        else if (uuid !== undefined)
            url_ += "uuid=" + encodeURIComponent("" + uuid) + "&"; 
        if (major === null)
            throw new Error("The parameter 'major' cannot be null.");
        else if (major !== undefined)
            url_ += "major=" + encodeURIComponent("" + major) + "&"; 
        if (minor === null)
            throw new Error("The parameter 'minor' cannot be null.");
        else if (minor !== undefined)
            url_ += "minor=" + encodeURIComponent("" + minor) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllQuizzes(_response);
        });
    }

    protected processGetAllQuizzes(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? QuizzesDTO.fromJS(resultData500) : new QuizzesDTO();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Create new quiz
     * @param token token
     * @param body (optional) 
     * @return successful operation
     */
    createQuiz(token: string, body: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/quizzes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateQuiz(_response);
        });
    }

    protected processCreateQuiz(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Get quiz by id
     * @param token token
     * @param quizId quizId
     * @return successful operation
     */
    findQuizz(token: string, quizId: string): Promise<string> {
        let url_ = this.baseUrl + "/quizzes/{quizId}";
        if (quizId === undefined || quizId === null)
            throw new Error("The parameter 'quizId' must be defined.");
        url_ = url_.replace("{quizId}", encodeURIComponent("" + quizId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindQuizz(_response);
        });
    }

    protected processFindQuizz(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? QuizDTO.fromJS(resultData500) : new QuizDTO();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Update quiz
     * @param token token
     * @param quizId quizId
     * @param body (optional) 
     * @return successful operation
     */
    updateQuiz(token: string, quizId: string, body: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/quizzes/{quizId}";
        if (quizId === undefined || quizId === null)
            throw new Error("The parameter 'quizId' must be defined.");
        url_ = url_.replace("{quizId}", encodeURIComponent("" + quizId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateQuiz(_response);
        });
    }

    protected processUpdateQuiz(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Remove quiz
     * @param token token
     * @param quizId quizId
     * @return successful operation
     */
    deleteQuiz(token: string, quizId: string): Promise<string> {
        let url_ = this.baseUrl + "/quizzes/{quizId}";
        if (quizId === undefined || quizId === null)
            throw new Error("The parameter 'quizId' must be defined.");
        url_ = url_.replace("{quizId}", encodeURIComponent("" + quizId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteQuiz(_response);
        });
    }

    protected processDeleteQuiz(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Activate quiz
     * @param token token
     * @param quizId quizId
     * @return successful operation
     */
    activateQuiz(token: string, quizId: string): Promise<string> {
        let url_ = this.baseUrl + "/quizzes/{quizId}/activate";
        if (quizId === undefined || quizId === null)
            throw new Error("The parameter 'quizId' must be defined.");
        url_ = url_.replace("{quizId}", encodeURIComponent("" + quizId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActivateQuiz(_response);
        });
    }

    protected processActivateQuiz(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Get quiz's scoreboard
     * @param token token
     * @param quizId quizId
     * @param userId (optional) userId
     * @param pageIndex (optional) the current page index
     * @param pageSize (optional) items in each page
     * @return successful operation
     */
    getQuizScoreboard(token: string, quizId: string, userId: string | undefined, pageIndex: string | undefined, pageSize: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/quizzes/{quizId}/scoreboard?";
        if (quizId === undefined || quizId === null)
            throw new Error("The parameter 'quizId' must be defined.");
        url_ = url_.replace("{quizId}", encodeURIComponent("" + quizId)); 
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuizScoreboard(_response);
        });
    }

    protected processGetQuizScoreboard(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ScoreboardDTO.fromJS(resultData500) : new ScoreboardDTO();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Submit answer
     * @param token token
     * @param body (optional) 
     * @return successful operation
     */
    submitQuizAnswers(token: string, body: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/quizzes/submitanswers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmitQuizAnswers(_response);
        });
    }

    protected processSubmitQuizAnswers(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? SubmitQuizAnswersResultDTO.fromJS(resultData500) : new SubmitQuizAnswersResultDTO();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Upload image
     * @param token token
     * @param body (optional) 
     * @return successful operation
     */
    uploadImage(token: string, body: Body | undefined): Promise<string> {
        let url_ = this.baseUrl + "/uploadImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadImage(_response);
        });
    }

    protected processUploadImage(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 !== undefined ? resultData500 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Get scoreboard
     * @param token token
     * @param quizId (optional) quizId
     * @param pageIndex (optional) the current page index
     * @param pageSize (optional) items in each page
     * @param sortBy (optional) field name to sort
     * @param pageOrientation (optional) next page or previous page
     * @return successful operation
     */
    getScoreboard(token: string, quizId: string | undefined, pageIndex: string | undefined, pageSize: number | undefined, sortBy: string | undefined, pageOrientation: boolean | undefined): Promise<string> {
        let url_ = this.baseUrl + "/scoreboard?";
        if (quizId === null)
            throw new Error("The parameter 'quizId' cannot be null.");
        else if (quizId !== undefined)
            url_ += "quizId=" + encodeURIComponent("" + quizId) + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageOrientation === null)
            throw new Error("The parameter 'pageOrientation' cannot be null.");
        else if (pageOrientation !== undefined)
            url_ += "pageOrientation=" + encodeURIComponent("" + pageOrientation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetScoreboard(_response);
        });
    }

    protected processGetScoreboard(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ScoreboardDTO.fromJS(resultData500) : new ScoreboardDTO();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Update Scoreboard
     * @param token token
     * @param userId userId
     * @param quizId quizId
     * @param points points
     * @return successful operation
     */
    updateScoreboard(token: string, userId: string, quizId: string, points: number): Promise<string> {
        let url_ = this.baseUrl + "/scoreboard?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (quizId === undefined || quizId === null)
            throw new Error("The parameter 'quizId' must be defined and cannot be null.");
        else
            url_ += "quizId=" + encodeURIComponent("" + quizId) + "&"; 
        if (points === undefined || points === null)
            throw new Error("The parameter 'points' must be defined and cannot be null.");
        else
            url_ += "points=" + encodeURIComponent("" + points) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateScoreboard(_response);
        });
    }

    protected processUpdateScoreboard(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ScoreboardDTO.fromJS(resultData500) : new ScoreboardDTO();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class RegisterDTO implements IRegisterDTO {
    fullName!: string;
    username!: string;
    email!: string;
    password!: string;
    isMobile!: boolean;

    constructor(data?: IRegisterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fullName = data["fullName"];
            this.username = data["username"];
            this.email = data["email"];
            this.password = data["password"];
            this.isMobile = data["isMobile"];
        }
    }

    static fromJS(data: any): RegisterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["email"] = this.email;
        data["password"] = this.password;
        data["isMobile"] = this.isMobile;
        return data; 
    }
}

export interface IRegisterDTO {
    fullName: string;
    username: string;
    email: string;
    password: string;
    isMobile: boolean;
}

export class LoginDTO implements ILoginDTO {
    usernameOrEmail!: string;
    password!: string;
    rememberMe!: boolean;
    isMobile!: boolean;

    constructor(data?: ILoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usernameOrEmail = data["usernameOrEmail"];
            this.password = data["password"];
            this.rememberMe = data["rememberMe"];
            this.isMobile = data["isMobile"];
        }
    }

    static fromJS(data: any): LoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usernameOrEmail"] = this.usernameOrEmail;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        data["isMobile"] = this.isMobile;
        return data; 
    }
}

export interface ILoginDTO {
    usernameOrEmail: string;
    password: string;
    rememberMe: boolean;
    isMobile: boolean;
}

export class LoginResultDTO implements ILoginResultDTO {
    token!: string;

    constructor(data?: ILoginResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.token = data["token"];
        }
    }

    static fromJS(data: any): LoginResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data; 
    }
}

export interface ILoginResultDTO {
    token: string;
}

export class ForgotPasswordDTO implements IForgotPasswordDTO {
    email!: string;

    constructor(data?: IForgotPasswordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IForgotPasswordDTO {
    email: string;
}

export class ResetPasswordDTO implements IResetPasswordDTO {
    password!: string;
    email!: string;

    constructor(data?: IResetPasswordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"];
            this.email = data["email"];
        }
    }

    static fromJS(data: any): ResetPasswordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["email"] = this.email;
        return data; 
    }
}

export interface IResetPasswordDTO {
    password: string;
    email: string;
}

export class UsersDTO implements IUsersDTO {
    total!: number;
    data!: UsersDTO_data[];

    constructor(data?: IUsersDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"];
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(UsersDTO_data.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UsersDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUsersDTO {
    total: number;
    data: UsersDTO_data[];
}

export class UpdateUserDTO implements IUpdateUserDTO {
    profileImgUrl!: string;
    fullName!: string;
    i18n!: string;

    constructor(data?: IUpdateUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profileImgUrl = data["profileImgUrl"];
            this.fullName = data["fullName"];
            this.i18n = data["i18n"];
        }
    }

    static fromJS(data: any): UpdateUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profileImgUrl"] = this.profileImgUrl;
        data["fullName"] = this.fullName;
        data["i18n"] = this.i18n;
        return data; 
    }
}

export interface IUpdateUserDTO {
    profileImgUrl: string;
    fullName: string;
    i18n: string;
}

export class UpdateRolesDTO implements IUpdateRolesDTO {
    roles!: string[];

    constructor(data?: IUpdateRolesDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRolesDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolesDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IUpdateRolesDTO {
    roles: string[];
}

export class RedeemPointsDTO implements IRedeemPointsDTO {
    point!: number;
    reason!: string;

    constructor(data?: IRedeemPointsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.point = data["point"];
            this.reason = data["reason"];
        }
    }

    static fromJS(data: any): RedeemPointsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RedeemPointsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["point"] = this.point;
        data["reason"] = this.reason;
        return data; 
    }
}

export interface IRedeemPointsDTO {
    point: number;
    reason: string;
}

export class CancelRedeemPointsDTO implements ICancelRedeemPointsDTO {
    redemptionId!: string;

    constructor(data?: ICancelRedeemPointsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.redemptionId = data["redemptionId"];
        }
    }

    static fromJS(data: any): CancelRedeemPointsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CancelRedeemPointsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redemptionId"] = this.redemptionId;
        return data; 
    }
}

export interface ICancelRedeemPointsDTO {
    redemptionId: string;
}

export class QuizzesDTO implements IQuizzesDTO {
    total!: number;
    data!: QuizzesDTO_data[];

    constructor(data?: IQuizzesDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"];
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(QuizzesDTO_data.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizzesDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuizzesDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuizzesDTO {
    total: number;
    data: QuizzesDTO_data[];
}

export class CreateQuizDTO implements ICreateQuizDTO {
    coverImageUrl!: string;
    title!: string;
    description!: string;
    state!: string;
    beacon!: QuizzesDTO_beacon;
    questions!: CreateQuizDTO_questions[];

    constructor(data?: ICreateQuizDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.beacon = new QuizzesDTO_beacon();
            this.questions = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.coverImageUrl = data["coverImageUrl"];
            this.title = data["title"];
            this.description = data["description"];
            this.state = data["state"];
            this.beacon = data["beacon"] ? QuizzesDTO_beacon.fromJS(data["beacon"]) : new QuizzesDTO_beacon();
            if (data["questions"] && data["questions"].constructor === Array) {
                this.questions = [];
                for (let item of data["questions"])
                    this.questions.push(CreateQuizDTO_questions.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateQuizDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuizDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coverImageUrl"] = this.coverImageUrl;
        data["title"] = this.title;
        data["description"] = this.description;
        data["state"] = this.state;
        data["beacon"] = this.beacon ? this.beacon.toJSON() : <any>undefined;
        if (this.questions && this.questions.constructor === Array) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateQuizDTO {
    coverImageUrl: string;
    title: string;
    description: string;
    state: string;
    beacon: QuizzesDTO_beacon;
    questions: CreateQuizDTO_questions[];
}

export class QuizDTO implements IQuizDTO {
    questionCount!: number;
    _id!: string;
    coverImageUrl!: string;
    title!: string;
    description!: string;
    state!: string;
    createdAt!: number;
    beacon!: QuizzesDTO_beacon;
    questions!: QuizzesDTO_questions[];

    constructor(data?: IQuizDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.beacon = new QuizzesDTO_beacon();
            this.questions = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.questionCount = data["questionCount"];
            this._id = data["_id"];
            this.coverImageUrl = data["coverImageUrl"];
            this.title = data["title"];
            this.description = data["description"];
            this.state = data["state"];
            this.createdAt = data["createdAt"];
            this.beacon = data["beacon"] ? QuizzesDTO_beacon.fromJS(data["beacon"]) : new QuizzesDTO_beacon();
            if (data["questions"] && data["questions"].constructor === Array) {
                this.questions = [];
                for (let item of data["questions"])
                    this.questions.push(QuizzesDTO_questions.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QuizDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionCount"] = this.questionCount;
        data["_id"] = this._id;
        data["coverImageUrl"] = this.coverImageUrl;
        data["title"] = this.title;
        data["description"] = this.description;
        data["state"] = this.state;
        data["createdAt"] = this.createdAt;
        data["beacon"] = this.beacon ? this.beacon.toJSON() : <any>undefined;
        if (this.questions && this.questions.constructor === Array) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuizDTO {
    questionCount: number;
    _id: string;
    coverImageUrl: string;
    title: string;
    description: string;
    state: string;
    createdAt: number;
    beacon: QuizzesDTO_beacon;
    questions: QuizzesDTO_questions[];
}

export class ScoreboardDTO implements IScoreboardDTO {
    total!: number;
    data!: ScoreboardDTO_data[];

    constructor(data?: IScoreboardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"];
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(ScoreboardDTO_data.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScoreboardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreboardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IScoreboardDTO {
    total: number;
    data: ScoreboardDTO_data[];
}

export class SubmitQuizAnswersDTO implements ISubmitQuizAnswersDTO {
    userId!: string;
    quizId!: string;
    answers!: SubmitQuizAnswersDTO_answers[];

    constructor(data?: ISubmitQuizAnswersDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.answers = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.quizId = data["quizId"];
            if (data["answers"] && data["answers"].constructor === Array) {
                this.answers = [];
                for (let item of data["answers"])
                    this.answers.push(SubmitQuizAnswersDTO_answers.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitQuizAnswersDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuizAnswersDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["quizId"] = this.quizId;
        if (this.answers && this.answers.constructor === Array) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISubmitQuizAnswersDTO {
    userId: string;
    quizId: string;
    answers: SubmitQuizAnswersDTO_answers[];
}

export class SubmitQuizAnswersResultDTO implements ISubmitQuizAnswersResultDTO {
    correctAnswerCount!: number;
    points!: number;

    constructor(data?: ISubmitQuizAnswersResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.correctAnswerCount = data["correctAnswerCount"];
            this.points = data["points"];
        }
    }

    static fromJS(data: any): SubmitQuizAnswersResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuizAnswersResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["correctAnswerCount"] = this.correctAnswerCount;
        data["points"] = this.points;
        return data; 
    }
}

export interface ISubmitQuizAnswersResultDTO {
    correctAnswerCount: number;
    points: number;
}

export class Body implements IBody {
    fileName!: string;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        return data; 
    }
}

export interface IBody {
    fileName: string;
}

export class UsersDTO_data implements IUsersDTO_data {
    _id!: string;
    username!: string;
    email!: string;
    profileImgUrl!: string;
    fullName!: string;
    i18n!: string;
    roles!: string[];
    scorePoint!: number;
    rewardPoint!: number;
    createdAt!: number;

    constructor(data?: IUsersDTO_data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(data?: any) {
        if (data) {
            this._id = data["_id"];
            this.username = data["username"];
            this.email = data["email"];
            this.profileImgUrl = data["profileImgUrl"];
            this.fullName = data["fullName"];
            this.i18n = data["i18n"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(item);
            }
            this.scorePoint = data["scorePoint"];
            this.rewardPoint = data["rewardPoint"];
            this.createdAt = data["createdAt"];
        }
    }

    static fromJS(data: any): UsersDTO_data {
        data = typeof data === 'object' ? data : {};
        let result = new UsersDTO_data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["username"] = this.username;
        data["email"] = this.email;
        data["profileImgUrl"] = this.profileImgUrl;
        data["fullName"] = this.fullName;
        data["i18n"] = this.i18n;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["scorePoint"] = this.scorePoint;
        data["rewardPoint"] = this.rewardPoint;
        data["createdAt"] = this.createdAt;
        return data; 
    }
}

export interface IUsersDTO_data {
    _id: string;
    username: string;
    email: string;
    profileImgUrl: string;
    fullName: string;
    i18n: string;
    roles: string[];
    scorePoint: number;
    rewardPoint: number;
    createdAt: number;
}

export class QuizzesDTO_beacon implements IQuizzesDTO_beacon {
    isActive!: boolean;
    uuid!: string;
    major!: string;
    minor!: string;

    constructor(data?: IQuizzesDTO_beacon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isActive = data["isActive"];
            this.uuid = data["uuid"];
            this.major = data["major"];
            this.minor = data["minor"];
        }
    }

    static fromJS(data: any): QuizzesDTO_beacon {
        data = typeof data === 'object' ? data : {};
        let result = new QuizzesDTO_beacon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isActive"] = this.isActive;
        data["uuid"] = this.uuid;
        data["major"] = this.major;
        data["minor"] = this.minor;
        return data; 
    }
}

export interface IQuizzesDTO_beacon {
    isActive: boolean;
    uuid: string;
    major: string;
    minor: string;
}

export class QuizzesDTO_answers implements IQuizzesDTO_answers {
    id!: string;
    décription!: string;
    isCorrect!: boolean;

    constructor(data?: IQuizzesDTO_answers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.décription = data["décription"];
            this.isCorrect = data["isCorrect"];
        }
    }

    static fromJS(data: any): QuizzesDTO_answers {
        data = typeof data === 'object' ? data : {};
        let result = new QuizzesDTO_answers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["décription"] = this.décription;
        data["isCorrect"] = this.isCorrect;
        return data; 
    }
}

export interface IQuizzesDTO_answers {
    id: string;
    décription: string;
    isCorrect: boolean;
}

export class QuizzesDTO_questions implements IQuizzesDTO_questions {
    id!: string;
    coverType!: string;
    coverUrl!: string;
    description!: string;
    answers!: QuizzesDTO_answers[];

    constructor(data?: IQuizzesDTO_questions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.answers = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.coverType = data["coverType"];
            this.coverUrl = data["coverUrl"];
            this.description = data["description"];
            if (data["answers"] && data["answers"].constructor === Array) {
                this.answers = [];
                for (let item of data["answers"])
                    this.answers.push(QuizzesDTO_answers.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizzesDTO_questions {
        data = typeof data === 'object' ? data : {};
        let result = new QuizzesDTO_questions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coverType"] = this.coverType;
        data["coverUrl"] = this.coverUrl;
        data["description"] = this.description;
        if (this.answers && this.answers.constructor === Array) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuizzesDTO_questions {
    id: string;
    coverType: string;
    coverUrl: string;
    description: string;
    answers: QuizzesDTO_answers[];
}

export class QuizzesDTO_data implements IQuizzesDTO_data {
    questionCount!: number;
    _id!: string;
    coverImageUrl!: string;
    title!: string;
    description!: string;
    state!: string;
    createdAt!: number;
    beacon!: QuizzesDTO_beacon;
    questions!: QuizzesDTO_questions[];

    constructor(data?: IQuizzesDTO_data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.beacon = new QuizzesDTO_beacon();
            this.questions = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.questionCount = data["questionCount"];
            this._id = data["_id"];
            this.coverImageUrl = data["coverImageUrl"];
            this.title = data["title"];
            this.description = data["description"];
            this.state = data["state"];
            this.createdAt = data["createdAt"];
            this.beacon = data["beacon"] ? QuizzesDTO_beacon.fromJS(data["beacon"]) : new QuizzesDTO_beacon();
            if (data["questions"] && data["questions"].constructor === Array) {
                this.questions = [];
                for (let item of data["questions"])
                    this.questions.push(QuizzesDTO_questions.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizzesDTO_data {
        data = typeof data === 'object' ? data : {};
        let result = new QuizzesDTO_data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionCount"] = this.questionCount;
        data["_id"] = this._id;
        data["coverImageUrl"] = this.coverImageUrl;
        data["title"] = this.title;
        data["description"] = this.description;
        data["state"] = this.state;
        data["createdAt"] = this.createdAt;
        data["beacon"] = this.beacon ? this.beacon.toJSON() : <any>undefined;
        if (this.questions && this.questions.constructor === Array) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuizzesDTO_data {
    questionCount: number;
    _id: string;
    coverImageUrl: string;
    title: string;
    description: string;
    state: string;
    createdAt: number;
    beacon: QuizzesDTO_beacon;
    questions: QuizzesDTO_questions[];
}

export class CreateQuizDTO_answers implements ICreateQuizDTO_answers {
    id!: string;
    description!: string;
    isCorrect!: boolean;

    constructor(data?: ICreateQuizDTO_answers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.description = data["description"];
            this.isCorrect = data["isCorrect"];
        }
    }

    static fromJS(data: any): CreateQuizDTO_answers {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuizDTO_answers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["isCorrect"] = this.isCorrect;
        return data; 
    }
}

export interface ICreateQuizDTO_answers {
    id: string;
    description: string;
    isCorrect: boolean;
}

export class CreateQuizDTO_questions implements ICreateQuizDTO_questions {
    id!: string;
    coverType!: string;
    coverUrl!: string;
    description!: string;
    answers!: CreateQuizDTO_answers[];

    constructor(data?: ICreateQuizDTO_questions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.answers = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.coverType = data["coverType"];
            this.coverUrl = data["coverUrl"];
            this.description = data["description"];
            if (data["answers"] && data["answers"].constructor === Array) {
                this.answers = [];
                for (let item of data["answers"])
                    this.answers.push(CreateQuizDTO_answers.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateQuizDTO_questions {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuizDTO_questions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coverType"] = this.coverType;
        data["coverUrl"] = this.coverUrl;
        data["description"] = this.description;
        if (this.answers && this.answers.constructor === Array) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateQuizDTO_questions {
    id: string;
    coverType: string;
    coverUrl: string;
    description: string;
    answers: CreateQuizDTO_answers[];
}

export class ScoreboardDTO_data implements IScoreboardDTO_data {
    userId!: string;
    name!: string;
    points!: number;

    constructor(data?: IScoreboardDTO_data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.name = data["name"];
            this.points = data["points"];
        }
    }

    static fromJS(data: any): ScoreboardDTO_data {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreboardDTO_data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["points"] = this.points;
        return data; 
    }
}

export interface IScoreboardDTO_data {
    userId: string;
    name: string;
    points: number;
}

export class SubmitQuizAnswersDTO_answers implements ISubmitQuizAnswersDTO_answers {
    questionId!: string;
    answerId!: number;

    constructor(data?: ISubmitQuizAnswersDTO_answers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionId = data["questionId"];
            this.answerId = data["answerId"];
        }
    }

    static fromJS(data: any): SubmitQuizAnswersDTO_answers {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuizAnswersDTO_answers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["answerId"] = this.answerId;
        return data; 
    }
}

export interface ISubmitQuizAnswersDTO_answers {
    questionId: string;
    answerId: number;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}